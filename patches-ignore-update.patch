diff --git a/README.md b/README.md
index 87f9dc0..d747e1f 100644
--- a/README.md
+++ b/README.md
@@ -117,6 +117,35 @@ There may be situations in which you want to ignore a patch supplied by a depend
 }
 ```
 
+### Sub-package Ignoring Patches
+
+In the event you need the patches-ignore of dependency packages to be relevant, the following settings will allow for these to bubble up.
+
+```json
+{
+  "require": {
+    "cweagans/composer-patches": "~1.0",
+    "drupal/drupal": "~8.2",
+    "drupal/lightning": "~8.1"
+  },
+  "extra": {
+    "enable-patches-ignore-subpackages": true,
+    "patches-ignore-whitelist": [
+      "drupal/lightning",
+      "drupal/core"
+    ]
+  }
+}
+```
+
+In the example provided, the settting ```enable-patches-ignore-subpackages``` set to ```TRUE``` which enables the ```patches-ignore``` from dependency packages to be collected and collated into the final patch list. You will also note, that we didn't include a ```patches-ignore``` section. This is completely optional at this point. Should you include it, it will be consumed and calculated into the final aggregated patch ignore list as usual.
+
+ A new section has been added: ```patches-ignore-whitelist```. This list of packages creates a whitelist of ```patches-ignore``` you wish to have consumed as opposed to allowing ALL dependencies to be factored in. This is a good way to limit the playing field.
+
+ This option really becomes useful when the dependencies for a project, which are managed independently of the main ```composer.json```, will be updated from upstream sources and having to maintain the main ```composer.json``` would lead to doubling up of efforts.
+
+ Consider a drupal distro as a dependency of a project which has patches and ```patches-ignore```.  You might like to take advantage of the distro but do not wish to duplicate its list in your project's ```composer.json``` file. With these options, you can allow the maintenance of these patch values to be handled upstream. You can even add another dependency to add or remove patches by including a new package and whitelisting. This can help to decentralize the controls and keep the main ```composer.json``` file clean of continual patch file management.
+
 ## Allowing to force the patch level (-pX)
 
 Some situations require to force the patchLevel used to apply patches on a particular package.
@@ -132,6 +161,23 @@ Its useful for packages like drupal/core which packages only a subdir of the ori
 }
 ```
 
+## Patch File Logging
+
+To help manage the potential onslaught of patches and patches-ignore files, the introduction of a logging option should help to review what the plugin is aggregating. You will get a full list of all patches requested, a list of patches to be ignored as well as the final outcome of the patch files removed from the full aggregated list. Use this to review if all the requested files have been properly consumed.
+
+```json
+{
+  "extra": {
+    "patches-log": {
+      "location": "patches",
+      "format": "txt"
+    }
+  }
+}
+```
+
+The ```format``` parameter can be either ```yml```, ```json```, ```txt``` or ```php``` as output formats.
+
 ## Using patches from HTTP URLs
 
 Composer [blocks](https://getcomposer.org/doc/06-config.md#secure-http) you from downloading anything from HTTP URLs, you can disable this for your project by adding a `secure-http` setting in the config section of your `composer.json`. Note that the `config` section should be under the root of your `composer.json`.
diff --git a/composer.json b/composer.json
index 1565b02..6dfabcb 100644
--- a/composer.json
+++ b/composer.json
@@ -14,6 +14,7 @@
     }
   ],
   "require": {
+    "ext-json": "*",
     "php": ">=5.3.0",
     "composer-plugin-api": "^1.0 || ^2.0"
   },
diff --git a/src/Patches.php b/src/Patches.php
index 4f77eb3..fd90e98 100644
--- a/src/Patches.php
+++ b/src/Patches.php
@@ -18,6 +18,8 @@ use Composer\Package\AliasPackage;
 use Composer\Package\PackageInterface;
 use Composer\Plugin\PluginInterface;
 use Composer\Installer\PackageEvents;
+use Composer\Repository\InstalledRepositoryInterface;
+use Composer\Repository\RepositoryManager;
 use Composer\Script\Event;
 use Composer\Script\ScriptEvents;
 use Composer\Installer\PackageEvent;
@@ -27,6 +29,8 @@ use Symfony\Component\Process\Process;
 
 class Patches implements PluginInterface, EventSubscriberInterface {
 
+  use PatchesIgnoreTrait;
+
   /**
    * @var Composer $composer
    */
@@ -47,6 +51,22 @@ class Patches implements PluginInterface, EventSubscriberInterface {
    * @var array $patches
    */
   protected $patches;
+  /**
+   * @var array $installedPatches
+   */
+  protected $installedPatches;
+  /**
+   * @var RepositoryManager $repositoryManager
+   */
+  protected $repositoryManager;
+  /**
+   * @var InstalledRepositoryInterface $localRepository
+   */
+  protected $localRepository;
+  /**
+   * @var PackageInterface $packages
+   */
+  protected $packages;
 
   /**
    * Apply plugin modifications to composer
@@ -61,6 +81,9 @@ class Patches implements PluginInterface, EventSubscriberInterface {
     $this->executor = new ProcessExecutor($this->io);
     $this->patches = array();
     $this->installedPatches = array();
+    $this->repositoryManager = $composer->getRepositoryManager();
+    $this->localRepository = $this->repositoryManager->getLocalRepository();
+    $this->packages = $this->localRepository->getPackages();
   }
 
   /**
@@ -85,7 +108,10 @@ class Patches implements PluginInterface, EventSubscriberInterface {
 
   /**
    * Before running composer install,
+   *
    * @param Event $event
+   *
+   * @throws \Exception
    */
   public function checkPatches(Event $event) {
     if (!$this->isPatchingEnabled()) {
@@ -93,22 +119,27 @@ class Patches implements PluginInterface, EventSubscriberInterface {
     }
 
     try {
-      $repositoryManager = $this->composer->getRepositoryManager();
-      $localRepository = $repositoryManager->getLocalRepository();
       $installationManager = $this->composer->getInstallationManager();
-      $packages = $localRepository->getPackages();
 
+      // Gather up the extra for the main composer.json
       $extra = $this->composer->getPackage()->getExtra();
       $patches_ignore = isset($extra['patches-ignore']) ? $extra['patches-ignore'] : array();
-
       $tmp_patches = $this->grabPatches();
-      foreach ($packages as $package) {
+
+      // Prep some baseline variables for use in later processes
+      $this->patches_flattened = $tmp_patches;
+      $this->patches_ignore_flattened = $patches_ignore;
+
+      // First Pass: Walk through packages against main composer.json
+      foreach ($this->packages as $package) {
         $extra = $package->getExtra();
         if (isset($extra['patches'])) {
+          $this->patches_flattened = $this->arrayMergeRecursiveDistinct($this->patches_flattened, $extra['patches']);
+          // Apply the main composer.json patches-ignore list
           if (isset($patches_ignore[$package->getName()])) {
-            foreach ($patches_ignore[$package->getName()] as $package_name => $patches) {
+            foreach ($patches_ignore[$package->getName()] as $package_name => $patches_to_ignore) {
               if (isset($extra['patches'][$package_name])) {
-                $extra['patches'][$package_name] = array_diff($extra['patches'][$package_name], $patches);
+                $extra['patches'][$package_name] = array_diff($extra['patches'][$package_name], $patches_to_ignore);
               }
             }
           }
@@ -118,14 +149,22 @@ class Patches implements PluginInterface, EventSubscriberInterface {
         $tmp_patches = $this->arrayMergeRecursiveDistinct($tmp_patches, $patches);
       }
 
+      // Second Pass: Remove patches from patches-ignore in dependencies
+      $this->doPatchesIgnoreCollation($tmp_patches);
+
       if ($tmp_patches == FALSE) {
         $this->io->write('<info>No patches supplied.</info>');
         return;
+      } else {
+        $this->io->write('<info>Patch logs written to the [' . $this->getPatchLogParameter('location') . '] folder.</info>', TRUE, IOInterface::VERBOSE);
+        $this->writePatchLog('patches-full', $this->patches_flattened, 'Full list of patches in all packages');
+        $this->writePatchLog('patches-ignore', $this->patches_ignore_flattened, 'Full list of patches to ignore from all packages');
+        $this->writePatchLog('patches', $tmp_patches, 'Final list of patches to be applied');
       }
 
       // Remove packages for which the patch set has changed.
       $promises = array();
-      foreach ($packages as $package) {
+      foreach ($this->packages as $package) {
         if (!($package instanceof AliasPackage)) {
           $package_name = $package->getName();
           $extra = $package->getExtra();
@@ -136,7 +175,7 @@ class Patches implements PluginInterface, EventSubscriberInterface {
             || ($has_patches && $has_applied_patches && $tmp_patches[$package_name] !== $extra['patches_applied'])) {
             $uninstallOperation = new UninstallOperation($package, 'Removing package so it can be re-installed and re-patched.');
             $this->io->write('<info>Removing package ' . $package_name . ' so that it can be re-installed and re-patched.</info>');
-            $promises[] = $installationManager->uninstall($localRepository, $uninstallOperation);
+            $promises[] = $installationManager->uninstall($this->localRepository, $uninstallOperation);
           }
         }
       }
@@ -156,6 +195,8 @@ class Patches implements PluginInterface, EventSubscriberInterface {
    * Gather patches from dependencies and store them for later use.
    *
    * @param PackageEvent $event
+   *
+   * @throws \Exception
    */
   public function gatherPatches(PackageEvent $event) {
     // If we've already done this, then don't do it again.
@@ -171,24 +212,28 @@ class Patches implements PluginInterface, EventSubscriberInterface {
 
     $this->patches = $this->grabPatches();
     if (empty($this->patches)) {
-      $this->io->write('<info>No patches supplied.</info>');
+      $this->io->write('<info>No patches supplied in main composer.json.</info>');
     }
 
     $extra = $this->composer->getPackage()->getExtra();
     $patches_ignore = isset($extra['patches-ignore']) ? $extra['patches-ignore'] : array();
 
+    $this->patches_flattened = $this->patches;
+    $this->patches_ignore_flattened = $patches_ignore;
+
     // Now add all the patches from dependencies that will be installed.
     $operations = $event->getOperations();
-    $this->io->write('<info>Gathering patches for dependencies. This might take a minute.</info>');
+    $this->io->write('<info>Gathering patches for dependencies. This may take a moment, please stand by...</info>');
     foreach ($operations as $operation) {
       if ($operation instanceof InstallOperation || $operation instanceof UpdateOperation) {
         $package = $this->getPackageFromOperation($operation);
         $extra = $package->getExtra();
         if (isset($extra['patches'])) {
+          $this->patches_flattened = $this->arrayMergeRecursiveDistinct($this->patches_flattened, $extra['patches']);
           if (isset($patches_ignore[$package->getName()])) {
-            foreach ($patches_ignore[$package->getName()] as $package_name => $patches) {
+            foreach ($patches_ignore[$package->getName()] as $package_name => $patches_to_ignore) {
               if (isset($extra['patches'][$package_name])) {
-                $extra['patches'][$package_name] = array_diff($extra['patches'][$package_name], $patches);
+                $extra['patches'][$package_name] = array_diff($extra['patches'][$package_name], $patches_to_ignore);
               }
             }
           }
@@ -200,12 +245,13 @@ class Patches implements PluginInterface, EventSubscriberInterface {
         }
       }
     }
-
     // Merge installed patches from dependencies that did not receive an update.
     foreach ($this->installedPatches as $patches) {
       $this->patches = $this->arrayMergeRecursiveDistinct($this->patches, $patches);
     }
 
+    $this->doPatchesIgnoreCollation();
+
     // If we're in verbose mode, list the projects we're going to patch.
     if ($this->io->isVerbose()) {
       foreach ($this->patches as $package => $patches) {
@@ -454,7 +500,7 @@ class Patches implements PluginInterface, EventSubscriberInterface {
     $output .= "Patches applied to this directory:\n\n";
     foreach ($patches as $description => $url) {
       $output .= $description . "\n";
-      $output .= 'Source: ' . $url . "\n\n\n";
+      $output .= 'Source: ' . $url . "\n\n";
     }
     file_put_contents($directory . "/PATCHES.txt", $output);
   }
@@ -509,14 +555,23 @@ class Patches implements PluginInterface, EventSubscriberInterface {
    * @see http://php.net/manual/en/function.array-merge-recursive.php#92195
    */
   protected function arrayMergeRecursiveDistinct(array $array1, array $array2) {
+    if (empty($array1)) {
+      $array1 = array();
+    }
     $merged = $array1;
 
-    foreach ($array2 as $key => &$value) {
+    foreach ($array2 as $key => $value) {
       if (is_array($value) && isset($merged[$key]) && is_array($merged[$key])) {
         $merged[$key] = $this->arrayMergeRecursiveDistinct($merged[$key], $value);
       }
       else {
-        $merged[$key] = $value;
+        // This checks to see if the patch file exists in the list of not.
+        // We should not rely on the description as a key to denote whether
+        // a patch is being installed or not or exists or not. Rather, the
+        // uniqueness of the patch path should be the defining comparison.
+        if ($this->isMultidimensionalArray($merged) || (!$this->isMultidimensionalArray($merged) && !is_array($value) && !array_key_exists($value, array_flip($merged))) || empty($merged)) {
+          $merged[$key] = $value;
+        }
       }
     }
 
diff --git a/src/PatchesIgnoreTrait.php b/src/PatchesIgnoreTrait.php
new file mode 100644
index 0000000..261a20c
--- /dev/null
+++ b/src/PatchesIgnoreTrait.php
@@ -0,0 +1,272 @@
+<?php
+
+/**
+ * @file
+ * For Patches Ignore functionality to piggy-back onto the main class.
+ */
+
+namespace cweagans\Composer;
+
+use Composer\Package\PackageInterface;
+use RecursiveArrayIterator;
+use RecursiveIteratorIterator;
+
+/**
+ * Trait to get the patches ignore functionality hooked into the main class.
+ *
+ * Using this trait will enhance the functionality of the Patches class.
+ *
+ */
+trait PatchesIgnoreTrait {
+
+  protected $patches_ignore_flattened;
+  protected $patches_flattened;
+
+  public function doPatchesIgnoreCollation(array &$tmp_patches = NULL) {
+    if ($tmp_patches === NULL) {
+      $tmp_patches = $this->patches;
+    }
+    if ($this->isPackagePatchingEnabled()) {
+      $patches = array();
+      foreach ($this->packages as $package) {
+        $extra = $package->getExtra();
+        // Review patches-ignore legality of the package per settings
+        if ($this->checkPatchesIgnoreLegal($package) && isset($extra['patches-ignore'])) {
+          $this->patches_ignore_flattened = $this->arrayMergeRecursiveDistinct($this->patches_ignore_flattened, $extra['patches-ignore']);
+          // Apply the package composer.json patches-ignore list
+          foreach ($this->flattenPatchesIgnore($extra['patches-ignore']) as $package_name => $patches_to_ignore) {
+            if (isset($tmp_patches[$package_name])) {
+              $tmp_patches[$package_name] = array_diff($tmp_patches[$package_name], $patches_to_ignore);
+            }
+          }
+        }
+      }
+      // If the patches array is empty, we're in CheckPatches step, otherwise
+      // set the patches variable as we're in the GatherPatches step.
+      if (!empty($this->patches)) {
+        $this->patches = $tmp_patches;
+      }
+    }
+  }
+
+  /**
+   * Checks if the root package enables sub-package patching.
+   *
+   * @return bool
+   *   Whether sub-package patching is enabled. Defaults to TRUE.
+   */
+  protected function isPackagePatchingEnabled() {
+    $extra = $this->composer->getPackage()->getExtra();
+
+    if (empty($extra['patches']) && empty($extra['patches-ignore']) && !isset($extra['patches-file'])) {
+      return isset($extra['enable-patches-ignore-subpackages']) ? $extra['enable-patches-ignore-subpackages'] : FALSE;
+    }
+    else {
+      return TRUE;
+    }
+  }
+
+  /**
+   * Checks to see if we have any Patches to Ignore from the whitelist.
+   *
+   * @return bool
+   *   Whether the whitelist exists or not.
+   */
+  protected function checkPatchesIgnoreWhitelist() {
+    $extra = $this->composer->getPackage()->getExtra();
+
+    if (empty($extra['patches-ignore-whitelist'])) {
+      return FALSE;
+    } else {
+      return TRUE;
+    }
+  }
+
+  /**
+   * Checks to see if the patches being ignored are in fact legal to use.
+   *
+   * @param \Composer\Package\PackageInterface $package
+   *
+   * @return bool
+   */
+  protected function checkPatchesIgnoreLegal(PackageInterface $package) {
+    if (!$this->isPackagePatchingEnabled()) {
+      return FALSE;
+    }
+
+    $extra = $package->getExtra();
+    $package_patches_ignore = isset($extra['patches-ignore']) ? $extra['patches-ignore'] : array();
+    $package_name = $package->getName();
+    if ($this->checkPatchesIgnoreWhitelist()) {
+      $patches_package_whitelist = $this->getPatchesIgnoreWhitelist();
+      if (in_array($package_name, $patches_package_whitelist)) {
+        return TRUE;
+      } else {
+        return FALSE;
+      }
+    }
+    if (!$this->checkPatchesIgnoreWhitelist() && isset($package_patches_ignore)) {
+      return TRUE;
+    }
+    return FALSE;
+  }
+
+  /**
+   * flattenPatchesIgnore returns the lowest leaf of a multidimensional array.
+   *
+   * If you have
+   *
+   * @param $package_patches_ignore
+   *
+   * @return array
+   */
+  protected function flattenPatchesIgnore($package_patches_ignore) {
+    if ($this->isMultidimensionalArray($package_patches_ignore)) {
+      foreach($package_patches_ignore as $package_name => $patches) {
+        if ($this->isMultidimensionalArray($patches)) {
+          $this->flattenPatchesIgnore($patches);
+        } else {
+          return [$package_name => $patches];
+        }
+      }
+    }
+    if (isset($patches)) {
+      return $patches;
+    }
+    return $package_patches_ignore;
+  }
+
+  /**
+   * Method to return the whitelist for the patches-ignore packages.
+   *
+   * @return array
+   */
+  protected function getPatchesIgnoreWhitelist() {
+    $extra = $this->composer->getPackage()->getExtra();
+    return $extra['patches-ignore-whitelist'];
+  }
+
+  /**
+   * Checks to see if the requested array is multidimensional or not.
+   *
+   * @param array $array
+   *   The array to check.
+   * @return bool
+   *   TRUE or FALSE return.
+   */
+  protected function isMultidimensionalArray(array $array)
+  {
+    if (array_key_first($array) === null) {
+      return FALSE;
+    }
+    return is_array($array[array_key_first($array)]);
+  }
+
+  /**
+   * Writes a patch log for debugging purposes.
+   *
+   * @param $filename
+   * @param array $patches
+   * @param string $message
+   */
+  protected function writePatchLog($filename, array $patches, $message = "Patches applied to this folder") {
+    $package = $this->composer->getPackage();
+
+    if ($this->checkPatchLog()) {
+      $directory = $this->getPatchLogParameter('location');
+      $file_format = strtolower($this->getPatchLogParameter('format'));
+      if (!file_exists($directory)) {
+        mkdir($directory, 0755);
+      }
+      switch ($file_format) {
+        case 'yml':
+        case 'yaml':
+          file_put_contents($directory . "/" . $filename . ".yml", yaml_emit($patches, JSON_PRETTY_PRINT));
+          break;
+        case 'json':
+          file_put_contents($directory . "/" . $filename . ".json", json_encode($patches, JSON_PRETTY_PRINT));
+          break;
+        case 'txt':
+        case 'text':
+          $output = $message . ":\n\n";
+          foreach ($patches as $patch => $patch_info) {
+            if (isset($patch_info) && !empty($patch_info)) {
+              if ($this->isMultidimensionalArray($patch_info)) {
+                $output .= '=== ' . $patch;
+                foreach ($this->flattenPatchesIgnore($patch_info) as $flatten_patch => $info) {
+                  $output .= ' ' . $flatten_patch . "\n";
+                  foreach ($info as $description => $url) {
+                    $output .= '   ' . $url . "\n";
+                    $output .= '   ' . $description . "\n\n";
+                  }
+                }
+              } else {
+                $output .= '=== ' . $patch . "\n";
+                foreach ($patch_info as $description => $url) {
+                  $output .= '   ' . $url . "\n";
+                  $output .= '   ' . $description . "\n\n";
+                }
+              }
+            }
+          }
+          file_put_contents($directory . "/" . $filename . ".txt", $output);
+
+          // TODO: Add a collapsed set of files here.
+
+          break;
+        case 'php':
+        default:
+          // Raw output
+          file_put_contents($directory . "/" . $filename . ".php", var_export($patches, true));
+      }
+    }
+  }
+
+  /**
+   * @return bool
+   */
+  protected function checkPatchLog() {
+    $extra = $this->composer->getPackage()->getExtra();
+    if (isset($extra['patches-log'])) {
+      return TRUE;
+    }
+    return FALSE;
+  }
+
+  /**
+   * @param $parameter
+   *
+   * @return false|mixed
+   */
+  protected function getPatchLogParameter($parameter) {
+    $extra = $this->composer->getPackage()->getExtra();
+    if (isset($extra['patches-log'][$parameter])) {
+      return $extra['patches-log'][$parameter];
+    }
+    return FALSE;
+  }
+
+  /**
+   * A recursive search for a needle in an array haystack.
+   *
+   * @param $needle
+   * @param array $haystack
+   *
+   * @return mixed
+   */
+  public function recursiveSearch($needle, array $haystack)
+  {
+    $iterator  = new RecursiveArrayIterator($haystack);
+    $recursive = new RecursiveIteratorIterator(
+      $iterator,
+      RecursiveIteratorIterator::SELF_FIRST
+    );
+    foreach ($recursive as $key => $value) {
+      if ($key === $needle) {
+        return TRUE;
+      }
+    }
+    return FALSE;
+  }
+
+}
